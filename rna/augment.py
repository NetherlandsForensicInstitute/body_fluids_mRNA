"""
Both functions to augment data and to manipulate augmented data.
"""

import numpy as np

from rna.utils import AugmentedData
from rna.analytics import combine_samples


def construct_random_samples(X, y, n, classes_to_include, n_features, binarize):
    """
    Returns n generated samples that contain classes classes_to_include. A sample is generated by random sampling a
    sample for each class, and adding the shuffled replicates.

    :param X: N_single_cell_experimental_samples array and within a list filled with for each
        n_single_cell_experimental_sample a N_measurements per sample x N_markers array
    :param y: list of length N_single_cell_experimental_samples filled with int labels of which cell type was measured
    :param n: number of samples to generate
    :param classes_to_include: iterable of int, cell type indices to include in the mixtures
    :param n_features: int: N_markers (=N_features)
    :param binarize: bool: if True transform samples into binary samples with threshold 150
    :return: n x n_features array
    """

    if len(classes_to_include) == 0:
        return np.zeros((n, n_features))
    data_for_class=[]
    for clas in classes_to_include:
        data_for_class.append(X[np.argwhere(np.array(y) == clas)[:, 0]])

    augmented_samples = []
    for i in range(n):
        sampled = []
        for j, clas in enumerate(classes_to_include):

            n_in_class = sum(np.array(y) == clas)
            sampled_sample = data_for_class[j][np.random.randint(n_in_class)[0]]
            n_replicates = len(sampled_sample)
            sampled.append(sampled_sample[np.random.permutation(n_replicates)])
        smallest_replicates = min([len(sample) for sample in sampled])

        combined_sample = []
        for i_replicate in range(smallest_replicates):
            combined_sample.append(np.max(np.array([sample[i_replicate] for sample in sampled]), axis=0))

        augmented_samples.append(np.array(combined_sample))

    combined_samples = binarize_and_combine_samples(augmented_samples, binarize)

    return combined_samples


def binarize_and_combine_samples(augmented_samples, binarize):
    if binarize:
        augmented_samples_bin = [
            np.where(augmented_samples[i] > 150, 1, 0) for i in
            range(len(augmented_samples))]
        combined_samples = combine_samples(augmented_samples_bin)
    else:
        combined_samples = combine_samples(augmented_samples)
    return combined_samples


def only_use_same_combinations_as_in_mixtures(X_augmented, y_nhot, y_nhot_mixtures):
    """
    Make sure that the combinations of cell types present in the mixtures dataset is the same in the augmented test
    dataset.
    """

    unique_mixture_combinations = np.unique(y_nhot_mixtures, axis=0)
    indices = [np.argwhere(np.all(y_nhot == unique_mixture_combinations[i, :], axis=1)).tolist() for i in range(unique_mixture_combinations.shape[0])]
    indices_flatter = [val for sublist in indices for val in sublist]
    indices_flattened = [val for sublist in indices_flatter for val in sublist]

    X_as_mixt = X_augmented[indices_flattened, :]
    y_nhot_as_mixt = y_nhot[indices_flattened, :]

    if X_as_mixt.shape[0] == 0:
        # when there is not a single match between the y_nhot and y_nhot_mixtures
        X_as_mixt = np.zeros([1, X_as_mixt.shape[1]])
        y_nhot_as_mixt = np.zeros([1, y_nhot_as_mixt.shape[1]])

    return X_as_mixt, y_nhot_as_mixt


def mixture_is_compatible_with_H1_H2_or_both(classes_in_current_mixture, disallowed_mixtures):
    """
    returns True if the current mixture is compatible with H1, H2 or both. If returns false, the mixture should not
    be in the augmented data, as it cannot exist under either H1 or H2.
    """
    if disallowed_mixtures is None:
        return True
    for disallowed_mixture in disallowed_mixtures:
        match_mixture = True
        for i, val in enumerate(disallowed_mixture):
            if val == 1:
                if i not in classes_in_current_mixture:
                    match_mixture = False
            if val == -1:
                if i in classes_in_current_mixture:
                    match_mixture = False
        if match_mixture:
            return False
    return True


def augment_data( X, y, n_celltypes, n_features, N_SAMPLES_PER_COMBINATION, label_encoder, prior=None, binarize=False,
                 from_penile=False, disallowed_mixtures=None):
    """
    Generate data for the power set of single cell types.

    :param X: n_samples x n_measurements per sample x n_markers array of measurements
    :param y: list of length N_single_cell_experimental_samples filled with int labels of which cell type was measured
    :param n_celltypes: int: number of single cell types
    :param n_features: int: n_markers
    :param N_SAMPLES_PER_COMBINATION: number of samples per combination. Note that this number differs when the prior
        distribution is not uniform.
    :param label_encoder: encoder that encodes labels with value between 0 and n_cell types-1
    :param prior: list of length n_celltypes representing the distribution of the augmented samples
    :param binarize: bool: if True transform samples into binary samples with threshold 150 and if False keep the
        original signal values but normalize (/1000).
    :param from_penile: bool: if True generate sample that always also contain penile skin and if False will never
        contain penile skin.
    :param disallowed_mixtures: list of vectors of length n_celltype. each of the vectors specifies a combination of
       celltypes that is inconsistent with either H1 or H2. 1 indicates presence, 0 absence, -1 irrelevance. Eg
       [[1,0,-1,-1,-1]] indicates there should be no mixtures that have the first cell type and lack the second cell
       type
    :return: n_experiments x n_markers array,
             n_experiments x n_celltypes matrix of 0, 1 indicating for each augmented sample which single cell type it
                was made up of. Does not contain column for penile skin
    """
    assert disallowed_mixtures is None or all([len(dm)==n_celltypes for dm in disallowed_mixtures])
    if not from_penile:
        n_celltypes_without_penile = n_celltypes
    else:
        n_celltypes_without_penile = n_celltypes - 1

    if prior is None: # uniform priors, exception for penile skin (should be coded more generally!)
        prior = [1] * n_celltypes

    assert len(prior) == n_celltypes, f"Not all cell types are given a prior value" \
                                      f"Make sure the length of the list(s) in 'prior' {len(prior)}) in settings is equal to" \
                                      f"the number of cell types {n_celltypes}."

    if len(np.unique(prior)) == 1:
        ratio_relevant_prior = 0.5
        ratio_other_priors = 0.5
    elif len(np.unique(prior)) == 2:
        counts = {prior.count(value): value for value in list(set(prior))}
        value_relevant_prior = counts[1]
        index_of_relevant_prior = prior.index(value_relevant_prior)
        counts.pop(1)
        value_other_priors = list(counts.values())[0]

        if value_relevant_prior > value_other_priors:
            ratio_relevant_prior = value_relevant_prior / (1 + value_relevant_prior)
            ratio_other_priors = 1-ratio_relevant_prior
        elif value_relevant_prior < value_other_priors:
            ratio_other_priors = value_other_priors / (1 + value_other_priors)
            ratio_relevant_prior = 1-ratio_other_priors
    else:
        raise ValueError("Cannot augment samples if there are more than two unique prior values. "
                         "Change 'priors' in settings.")

    if X.size == 0:
        # This is the case when calibration_size = 0.0, this is an implicit way to
        # ensure that calibration is not performed.
        X_augmented=None
        y_nhot_augmented=np.zeros((0, n_celltypes))

    else:
        X_augmented = np.zeros((0, n_features))
        N_SAMPLES = int(2 * N_SAMPLES_PER_COMBINATION * ratio_relevant_prior * (2 ** (n_celltypes_without_penile-1)) + \
                    2 * N_SAMPLES_PER_COMBINATION * ratio_other_priors * 2 ** ((n_celltypes_without_penile-1)))
        assert N_SAMPLES == N_SAMPLES_PER_COMBINATION * 2 ** n_celltypes_without_penile
        y_nhot_augmented = np.zeros((N_SAMPLES, n_celltypes), dtype=int)

        begin = 0
        for i in range(2 ** n_celltypes_without_penile):
            binary = bin(i)[2:]
            while len(binary) < n_celltypes:
                binary = '0' + binary

            # figure out which classes will be in the combination each iteration
            classes_in_current_mixture = []
            if not from_penile:
                for i_celltype in range(len(label_encoder.classes_)):
                    if binary[-i_celltype - 1] == '1':
                        classes_in_current_mixture.append(i_celltype)
            else:
                classes_str = label_encoder.classes_.tolist()
                classes_str.remove('Skin.penile')
                classes = np.array([label_encoder.transform([class_str]) for class_str in classes_str]).ravel()
                classes_map = {i:classes[i] for i in range(len(classes))}
                for i_celltype in range(len(classes)):
                    if binary[-i_celltype - 1] == '1':
                        classes_in_current_mixture.append(classes_map[i_celltype])
                # also (always) add penile skin samples.
                classes_in_current_mixture.append(int(label_encoder.transform(['Skin.penile'])))

            try:
                if index_of_relevant_prior in classes_in_current_mixture:
                    Np = 2 * ratio_relevant_prior
                else:
                    Np = 2 * ratio_other_priors
            except:
                Np = 1

            # NB this will not give you the correct number for all combinations of background levels and
            # N_SAMPLES_PER_COMBNATION, due to rounding errors.
            end = round(begin + N_SAMPLES_PER_COMBINATION * Np)
            if mixture_is_compatible_with_H1_H2_or_both(classes_in_current_mixture, disallowed_mixtures):

                if not from_penile:
                    for i_celltype in range(len(label_encoder.classes_)):
                        if binary[-i_celltype - 1] == '1':
                            y_nhot_augmented[begin:end, i_celltype] = 1
                else:
                    for i_celltype in range(len(label_encoder.classes_)):
                        if binary[-i_celltype - 1] == '1':
                            y_nhot_augmented[begin:end, classes_map[i_celltype]] = 1
                    y_nhot_augmented[begin:end, int(label_encoder.transform(['Skin.penile']))] = 1

                X_augmented = np.append(X_augmented,
                                        construct_random_samples(X, y, end - begin, classes_in_current_mixture, n_features,
                                                                 binarize=binarize), axis=0)
                begin = end
            else:
                # mixture is not compatible, shorten y_nhot_augmented
                y_nhot_augmented = np.delete(y_nhot_augmented, np.arange(begin,end), 0)

        if not binarize:
            X_augmented = X_augmented / 1000

    if from_penile:
        assert np.sum(y_nhot_augmented[:, int(label_encoder.transform(['Skin.penile']))]) == y_nhot_augmented.shape[0]

    return X_augmented, y_nhot_augmented[:, :n_celltypes]


def augment_splitted_data(X_train, y_train, X_calib, y_calib, X_test, y_test, y_nhot_mixtures, n_celltypes, n_features,
                          label_encoder, prior, binarize, from_penile, nsamples, disallowed_mixtures) -> AugmentedData:
    """
    Creates augmented samples for train, calibration and test data and saves it within a class.
    NB priors are always uniform for test data

    :param X_train: n_train_samples x n_features array of measurements
    :param y_train: list of length n_train_samples of labels
    :param X_calib: n_calibration_samples x n_features array of measurements
    :param y_calib: list of length n_calibration_samples of labels
    :param X_test: n_test_samples x n_features array of measurements
    :param y_test: list of length n_test_samples of labels
    :param y_nhot_mixtures: n_mixture_samples x n_celltypes array of labels
    :param n_celltypes: int: number of single cell types
    :param n_features: int: N_markers (=N_features)
    :param label_encoder: encoder that encodes labels with value between 0 and n_cell types-1
    :param prior: list of length n_celltypes representing the distribution of the augmented samples
    :param binarize:  bool: if True transform samples into binary samples with threshold 150 and if False keep the
        original signal values but normalize (/1000).
    :param from_penile: bool: if True generate sample that always also contain penile skin and if False will never
        contain penile skin.
    :param disallowed_mixtures: list of vectors of length n_celltype. each of the vectors specifies a combination of
       celltypes that is inconsistent with either H1 or H2. 1 indicates presence, 0 absence, -1 irrelevance. Eg
       [[1,0,-1,-1,-1]] indicates there should be no mixtures that have the first cell type and lack the second cell
       type
    :return: class with augmented samples for train, calibration, test and test as mixtures
    """

    X_train_augmented, y_train_nhot_augmented = augment_data(X_train, y_train, n_celltypes, n_features,
                                                             nsamples[0], label_encoder, prior,
                                                             binarize=binarize, from_penile=from_penile,
                                                             disallowed_mixtures=disallowed_mixtures)
    X_calib_augmented, y_calib_nhot_augmented = augment_data(X_calib, y_calib, n_celltypes, n_features,
                                                             nsamples[1], label_encoder, prior,
                                                             binarize=binarize, from_penile=from_penile,
                                                             disallowed_mixtures=disallowed_mixtures)
    # use uniform priors for test data
    if not X_test is None:
        X_test_augmented, y_test_nhot_augmented = augment_data(X_test, y_test, n_celltypes, n_features,
                                                               nsamples[2], label_encoder, [1] * n_celltypes,
                                                               binarize=binarize, from_penile=from_penile,
                                                               disallowed_mixtures=disallowed_mixtures)
        X_test_as_mixtures_augmented, y_test_as_mixtures_nhot_augmented = only_use_same_combinations_as_in_mixtures(
            X_test_augmented, y_test_nhot_augmented, y_nhot_mixtures)
        print('test:', X_test_augmented.shape)
        print('testasm:', X_test_as_mixtures_augmented.shape)
    else:
        X_test_as_mixtures_augmented=y_test_nhot_augmented=y_test_as_mixtures_nhot_augmented=None
        X_test_augmented=None

    print('train:', X_train_augmented.shape)
    print('calib:', X_calib_augmented.shape)

    class_to_return = AugmentedData(X_train_augmented, y_train_nhot_augmented, X_calib_augmented, y_calib_nhot_augmented, \
           X_test_augmented, y_test_nhot_augmented, X_test_as_mixtures_augmented, y_test_as_mixtures_nhot_augmented)


    return class_to_return


class MultiLabelEncoder():
    """
    Class that converts list of labels into nhot-encoded vectors and the other way around.

    :param n_classes: the number of single cell types
    :param nhot_of_combinations: n_unique_combinations x n_classes matrix containing all unique combinations of cell
        types.
    """

    def __init__(self, n_classes):
        self.n_classes = n_classes
        self.nhot_of_combinations = make_nhot_matrix_of_combinations(n_classes)

    def nhot_to_labels(self, y_nhot):
        """
        Transforms a nhot encoded matrix into a list of labels.
        """
        y = np.array([np.argwhere(np.all(self.nhot_of_combinations == y_nhot[i, :], axis=1)).flatten() for i in range(y_nhot.shape[0])])
        return y.ravel()

    def labels_to_nhot(self, y):
        """
        Transforms a list of labels into a nhot encoded matrix.
        """
        if len(y.shape) == 1 or y.shape[1] == 1:
            if not np.all(np.unique(y) == [0, 1]): # this when the model predicts one target class in hot encoded, but
                # it is seen as a list of labels being predicted.
                n = y.shape[0]
                # TODO: FutureWarning: arrays to stack must be passed as a "sequence" ...
                y_nhot = np.vstack(self.nhot_of_combinations[y[i], :] for i in range(n))
        return y_nhot

    def transform_single(self, y):
        """
        Transforms the MultiLabelEncoded labels into original labels of the single cell type data set.
        """
        y = y.reshape(-1, 1)
        y_transformed = np.zeros_like(y)
        for label in np.unique(y):
            y_transformed[np.argwhere(np.all(y == label, axis=1)).flatten()] = np.log2(label)

        return y_transformed

    def inv_transform_single(self, y):
        """
        Transforms the original labels of the single cell type data set into the MultiLabelEncoded labels
        """
        y_transformed = np.zeros_like(y)
        for label in np.unique(y):
            y_transformed[np.argwhere(np.all(y == label, axis=1)).flatten()] = 2 ** label

        return y_transformed


def make_nhot_matrix_of_combinations(N):
    """
    Makes nhot encoded matrix with all possible combinations of existing single cell types.

    :param N: int
    :return: 2 ** N x n_celltypes matrix nhot encoded
    """

    def int_to_binary(i):
        binary = bin(i)[2:]
        while len(binary) < N:
            binary = '0' + binary
        return np.flip([int(j) for j in binary]).tolist()

    return np.array([int_to_binary(i) for i in range(2**N)])